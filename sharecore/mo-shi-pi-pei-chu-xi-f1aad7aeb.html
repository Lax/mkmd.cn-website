
<!DOCTYPE HTML>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
  <title>ShareCore</title>

  <meta name="author" content="Justin Huang">
  
  <meta name="description" content="模式匹配初析 Aug 24th, 2014 前几天看到篇C#6.0的draft spec，发现C#6.0里将惊现模式匹配。如是便在做了翻宣讲说“模式匹配”是一个很好用的特性，
但是不知道跟C#的结合会怎么样。而同时却又发现周边了解“模式匹配”的人好少，于是诞生了写一篇文章稍微介绍下这 &hellip;">
  
  

  <link rel="canonical" href="http://sharecore.net/blog/2014/08/24/mo-shi-pi-pei-chu-xi">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/rss.xml" rel="alternate" title="ShareCore" type="application/atom+xml">
</head>
  
<body class="default">
  <div id="wrapper">
    <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!-- <link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
 -->
  
<script type="text/javascript" src="http://tajs.qq.com/stats?sId=30017637" charset="UTF-8"></script>
<script src="http://code.jquery.com/jquery-latest.min.js"  charset="UTF-8"></script>
<script type="text/javascript" src="/javascripts/jquery.slides.min.js" charset="UTF-8"></script>
<style>
    #slides .slidesjs-navigation {
      margin-top:3px;
    }

    #slides .slidesjs-previous {
      margin-right: 5px;
      float: left;
    }

    #slides .slidesjs-next {
      margin-right: 5px;
      float: left;
    }

    .slidesjs-pagination {
      margin: 6px 0 0;
      float: right;
      list-style: none;
    }

    .slidesjs-pagination li {
      float: left;
      margin: 0 1px;
    }

    .slidesjs-pagination li a {
      display: block;
      width: 13px;
      height: 0;
      padding-top: 13px;
      background-image: url(/img/pagination.png);
      background-position: 0 0;
      float: left;
      overflow: hidden;
    }

    .slidesjs-pagination li a.active,
    .slidesjs-pagination li a:hover.active {
      background-position: 0 -13px
    }

    .slidesjs-pagination li a:hover {
      background-position: 0 -26px
    }

    #slides a:link,
    #slides a:visited {
    }

    #slides a:hover,
    #slides a:active {
    }

    .navbar {
      overflow: hidden
    }
  </style>
<div id="header">
  <h1><a href="/">ShareCore</a></h1>
  
    <p>Jutin Huang's Blog</p>
  
</div>
<ul id="social-links">
  
    <li><a class="feed" href="/rss.xml" title="RSS">RSS</a></li>
  
  
  
    <li> <a class="github" href="https://github.com/justinhuang917" title="GitHub">GitHub</a> </li>
  
</ul>
<div class="clear"></div>
<ul id="nav">
  
    <li> <a href="/">blog</a> </li>
  

  
    <li><a href="/blog/archives">archives</a></li>
  
   <li><a href="/md" target="_blank">Markdown编辑</a></li>

  
    <li><a href="/about.html">关于我</a></li>
  
  
    <li><a href="/redwine.html">红酒推荐</a></li>
  
</ul>

    <div id="main"> <div class="post-header">
  
    <h1 class="post-title">模式匹配初析</h1>
  
  








  


<time datetime="2014-08-24T15:30:00+08:00" pubdate data-updated="true">Aug 24<span>th</span>, 2014</time>
</div>

<div class="post-content"><pre><code>前几天看到篇C#6.0的draft spec，发现C#6.0里将惊现模式匹配。如是便在做了翻宣讲说“模式匹配”是一个很好用的特性，
但是不知道跟C#的结合会怎么样。而同时却又发现周边了解“模式匹配”的人好少，于是诞生了写一篇文章稍微介绍下这
一功能特性的想法。
</code></pre>

<p>如果说模式匹配这一概念有人不知道，但是正则表达式应该绝大多数的程序员都知道的了。而简言之，<strong>模式匹配就是更强大的正则表达式，或者说正则表达式是模式匹配这一概念在字符串处理上的一个应用</strong>。有了正则表达式为例，我们可以为模式匹配定义一个更为通用的定义：</p>

<pre><code>模式匹配是判断输入的数据（信息）是否与特定的结构相匹配，并按模式从中取得数据（信息）。
</code></pre>

<p>如下以正则表达式为例，从输入数据value里按pattern提取数据digits的模式匹配过程。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">value</span><span class="o">=</span><span class="s2">&quot;abc123&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">pattern</span><span class="o">=</span><span class="sr">/\d/g</span><span class="p">;</span><span class="c1">//定义模式</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">digits</span><span class="o">=</span><span class="nx">value</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">pattern</span><span class="p">);</span><span class="c1">//[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>那更广泛意义上的模式匹配是什么呢？其实很简单，就是输入/提取数据（信息）的范围不再局限为字符串了，甚至可以是编程语言支持的所有数据结构。第一次接触模式匹配这一概念，是前几年学习erlang的时候，下面就主要以erlang为例，来对模式匹配稍作介绍。</p>

<p>先上点erlang里的&#8221;甜点&#8221;为例来说明：</p>

<p>(erlang基础知识：大写字母开头的声明为变量，比如下面例子里的P，H,T;小写字母的声明是原子,比如abc)</p>

<pre><code>模式{abc，P}与输入数据项{abc,123}匹配，并在匹配的同时，发生绑定P-&gt;123

模式[H|T]与输入数据项[1,2,3,4]匹配，并在匹配的同时，发生绑定H-&gt;1,T-&gt;[2,3,4]
</code></pre>

<p>第一个例子匹配的过程如下：</p>

<p>1.先进行类型匹配：模式和数据项都是一个元组（“{}”），匹配通过。</p>

<p>2.模式元组的第一个元素为常量，进行匹配：模式和数据项都是“abc”,匹配通过。</p>

<p>3.模式元组的第二个元素是一个变量P，同时后面不再有任何元素，结束匹配，并将P绑定到数据项第一个元素后的所有元素。</p>

<p>第二个例子匹配过程如下：</p>

<p>1.先进行类型匹配，模式和数据项都是一个列表（“[]”），匹配通过。</p>

<p>2.模式”[H|T]&#8221;表示的是一个“首尾”匹配，用“|”分开两个变量（H，T），H表示的首元素匹配，T表示尾部（除首元素外的所有元素）匹配。匹配是通过的,并绑定H和T的值为首元素和尾元素。</p>

<p>再来一个高级点的例子：<strong>使用模式匹配来处理消息的接收</strong>：</p>

<p>(erlang基础知识：erlang的调用是基于CSP的，各个actor之间通过消息通讯带完成调用;receive原语是erlang提供的消息接收机制，可监听和接收来自其它actor发送来的消息;&#8221;！&#8221;标识符用于向对应的actor发送消息)。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='erlang'><span class='line'><span class="nf">loop</span><span class="p">(</span><span class="nv">Dict</span><span class="p">)</span> <span class="o">-&gt;</span>
</span><span class='line'>  <span class="k">receive</span>  <span class="c">%消息接收的原语，获取调用方的消息</span>
</span><span class='line'>      <span class="p">{</span><span class="n">store</span><span class="p">,</span> <span class="nv">Key</span><span class="p">,</span> <span class="nv">Value</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="c">%匹配数据存储的消息，&quot;store&quot;</span>
</span><span class='line'>          <span class="n">loop</span><span class="p">(</span><span class="nn">dict</span><span class="p">:</span><span class="n">store</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Value</span><span class="p">,</span> <span class="nv">Dict</span><span class="p">));</span> <span class="c">%真实的存储</span>
</span><span class='line'>      <span class="p">{</span><span class="nv">From</span><span class="p">,</span> <span class="p">{</span><span class="nb">get</span><span class="p">,</span> <span class="nv">Key</span><span class="p">}}</span> <span class="o">-&gt;</span> <span class="c">%匹配数据获取的消息, From匹配消息来源，</span>
</span><span class='line'>          <span class="nv">From</span> <span class="o">!</span> <span class="nn">dict</span><span class="p">:</span><span class="n">fetch</span><span class="p">(</span><span class="nv">Key</span><span class="p">,</span> <span class="nv">Dict</span><span class="p">),</span> <span class="c">%向查询请求消息来源发送查询结果消息</span>
</span><span class='line'>          <span class="n">loop</span><span class="p">(</span><span class="nv">Dict</span><span class="p">)</span> <span class="c">%尾递归：持续监听新的消息 </span>
</span><span class='line'><span class="k">end</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="nv">Pid</span> <span class="o">=</span> <span class="nb">spawn</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span> <span class="c">%启动一个进程(actor)，Pid为进程号</span>
</span><span class='line'>
</span><span class='line'><span class="nv">Pid</span><span class="o">!</span><span class="p">{</span><span class="n">store</span> <span class="p">,</span><span class="n">key1</span><span class="p">,</span><span class="s">&quot;123&quot;</span><span class="p">}</span> <span class="c">%向进程发送一个键值对存储消息</span>
</span><span class='line'>
</span><span class='line'><span class="nv">Pid</span><span class="o">!</span><span class="p">{</span><span class="nb">get</span><span class="p">,</span><span class="n">key1</span><span class="p">}</span> <span class="c">%发送一个查询消息，获取&quot;key1&quot;对应的值</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面展示例子模式匹配在erlang中进行消息匹配的使用，需要注意的一点是，这里的<strong>匹配是从上到下来进行的</strong>，即会先进行“store”的匹配，匹配失败的话才进行“get”匹配。消息匹配是erlang里的一项杀手锏特性，它能大大减少在消息处理的代码量，代码只要专注于实际算法的实现即可，将相应消息的解析和内容提取，交给模式匹配来完成。</p>

<p>从本质上来讲，<strong>模式匹配体现的是一个解构的过程和手段</strong>，解构是日常编程过程中一个非常常见的场景，比如编译器将程序代码解析为一个抽象语法树（AST）就是一个解构的过程，再比如，将XML/JSON进行反序列化为程序对象也是一例。对于许多语言，并未提供强大的模式匹配特性，但是为了提供<strong>可扩展</strong>的解构功能，一般都会采取一些设计模式来解决。比如面向对象编程里，将<strong>解析操作抽离出独立的模块</strong>，采取基于基类的虚方法/抽象方法扩展的方式，然后结合想对应的规则配置，来完成有区别性的模式解构。但是，这样的方式，稍显笨重，代码量也更多，与模式匹配相比，不在一个复杂度等级之上。</p>

<p>去年我用golang写了一个web框架，其中的路由解析过程就采取了类似的方式（代码位置：<a href="https://github.com/JustinHuang917/gof">https://github.com/JustinHuang917/gof</a>）。通过如以下路由规则配置，匹配不同的URL模式，从URL中提取相应的参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="s2">&quot;RouteRules&quot;</span><span class="err">:</span><span class="p">[</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="nt">&quot;/Order/{id:[0-9]+}&quot;</span><span class="p">:</span>
</span><span class='line'>              <span class="p">{</span><span class="nt">&quot;controller&quot;</span><span class="p">:</span><span class="s2">&quot;Order&quot;</span><span class="p">,</span><span class="nt">&quot;action&quot;</span><span class="p">:</span><span class="s2">&quot;Order&quot;</span><span class="p">,</span><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="s2">&quot;0&quot;</span><span class="p">}</span>
</span><span class='line'>      <span class="p">},</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>          <span class="nt">&quot;/{controller}/{action}&quot;</span><span class="p">:</span>
</span><span class='line'>              <span class="p">{</span><span class="nt">&quot;controller&quot;</span><span class="p">:</span><span class="s2">&quot;Home&quot;</span><span class="p">,</span><span class="nt">&quot;action&quot;</span><span class="p">:</span><span class="s2">&quot;Index&quot;</span><span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个看似简单功能，我花了200多行代码才得以完成，使用的还是堪称语法最为精简的Golang，而如果使用Java/C#来完成，代码量肯定还要增加不少。而如果语言本身具有强大的模式匹配的话，实现代码将会变得非常精简。而这一次C#6.0声称引入模式匹配，希望是面向对象语言领域的一次有益尝试。</p>

<p>同时，我也希望我喜欢的Golang在模式匹配上迈开尝试的脚步，在现有的goroutine+channel的组合上应用模式匹配，将是一件非常有效率的实践。现在Golang提供”select..case&#8230;“机制只能识别不同channel返回的消息，而不能识别实际消息的内容，这一点来说，与erlang相比，降低了CSP的编程效率。</p>

<p>总结：</p>

<p>模式匹配是来自函数式编程领域的高效的编程功能特性，它能成倍增加“解构”代码的编写效率，明显降低代码复杂度。同时，尽管大多数的编程语言，尚未提供这一功能，但是实际代码编写过程中，我们可以借鉴其基于模式声明的思想，抽离出相应的模式匹配模块，在保证可扩展性的同时，控制数据（信息）匹配带来的代码复杂度。</p>

<hr />

<p>如果您觉得这篇文字有意思，欢迎转发！欢迎更多的朋友们关注我的微信公众号：<strong>JustinNotes</strong></p>

<hr />
</div>


<div class="post-single">
  <div class="post-meta">
    


    
      <div class="sharing">
  
  
  
</div>

    
  </div>
  <div class="clear"></div>

  
    <div id="comments">
      <h2>Comments</h1>
      <div id="disqus_thread" aria-live="polite"></div>
    </div>
  
</div>
 </div>
    <div id="footer">
  <div class="panels">
    <div class="license">
      <h2>License</h2>
      <p>如非特别声明，本 Blog 的文章由 Justin Huang 创作，采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">知识共享署名-非商业性使用-相同方式共享 3.0 Unported 许可协议</a>进行许可。</p>
    </div>

    <div class="posts">
      <h2>Recent Posts</h2>
      <ul>
        
          <li>
            <a href="/blog/2014/08/24/mo-shi-pi-pei-chu-xi/">模式匹配初析</a>
          </li>
        
          <li>
            <a href="/blog/2014/08/10/zi-fu-bian-ma-chang-shi-ji-wen-ti-jie-xi/">字符编码常识及问题解析</a>
          </li>
        
          <li>
            <a href="/blog/2014/08/02/qian-tan-fu-wu-hua-kuang-jia-de-ji-ben-gong-neng/">浅谈服务化架构</a>
          </li>
        
          <li>
            <a href="/blog/2014/07/27/mian-dui-pen-zi-ming-zhe-bao-shen/">面对喷子 明哲保身</a>
          </li>
        
          <li>
            <a href="/blog/2014/07/20/ji-zhu-de-jin-hua/">技术的进化</a>
          </li>
        
      </ul>
    </div>

    <div class="douban">
      <h2>Reading</h2>
      
        <script type="text/javascript" src="http://www.douban.com/service/badge/76875311/?show=collection&amp;select=favorite&amp;n=8&amp;columns=4&amp;hidelogo=yes&amp;hideself=yes&amp;cat=book" ></script>
        <a href="http://www.douban.com/people/76875311" class="view-douban">76875311 on douban.com&raquo;</a>
      
    </div>
  </div>

  <p class="powered">
    Powered by <a href="http://octopress.org">Octopress</a> and <a href="https://github.com/iwinux/compbits">Compbits</a>
  </p>
</div>

  </div> <!-- #wrapper end -->

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37230829-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


  

<script type="text/javascript">
      var disqus_shortname = 'sharecore';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://sharecore.net/blog/2014/08/24/mo-shi-pi-pei-chu-xi/';
        var disqus_url = 'http://sharecore.net/blog/2014/08/24/mo-shi-pi-pei-chu-xi/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


  

  

  

</body>
</html>
